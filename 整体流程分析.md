# 整体流程分析

### 初始化

* 设置SIGPIPE信号默认处理函数为SIG_IGN
* 初始化mime类型
* 创建epoll句柄（采用epoll_create1(int flag)），初始化事件数组
* 创建线程池，每个threadpoolWorker通过互斥锁来进行安全地获取任务队列中的请求任务，互斥锁只用于获取任务，完成任务获取后开锁再执行任务，达到与其他线程并行执行任务的目的
* 创建socket并绑定端口开始监听，设置监听端口非阻塞
* 将监听端口注册到epoll中并设置为边缘触发(ET)模式，开始循环等待事件发生并处理

### 事件处理流程

* 当事件发生时，先获取事件请求
  * 若监听到的事件为监听socket的事件
    * 建立连接事件，接收连接，设置非阻塞，给该连接创建一个http请求对象
    * 给该请求添加一个计时器，用于超时关闭
    * 将请求的文件描述符注册到epoll中
  * 若监听到的事件为其他请求事件
    * 先排除错误事件（EPOLLERR、EPOLLHUP或非EPOLLIN事件）
    * 分离请求的计时器，将请求放入线程池的任务队列，线程池通过条件变量唤醒一个线程来处理请求

### 请求处理流程

* 从请求事件的fd中读取全部数据(ET模式需要一次读完全部数据)进行解析处理
  * 若读到数据为空，判断errno是否为EAGAIN（因为接口为非阻塞，读不到数据可能是数据未到达或请求终止，read会直接返回EAGAIN错误码），若为EAGAIN，则下次事件触发时重新处理，该请求对象的处理次数设置一个最大值，超过该最大值则不再监听该请求的事件，直接返回
  * 读取到数据，解析URI和请求头，解析正确后根据请求参数发送响应信息，解析或处理出错直接返回
* 若请求解析和响应成功，判断该请求是否为长连接(keep-alive)，若为短连接，直接返回
* 若为长连接，则将该连接的请求对象复位，下次请求过来时重新利用，减少对象的创建和销毁开销
* 给请求添加新的计时器，再epoll_mod IN事件，只要该句柄还有数据可以读，epoll_wait就会响应（这样可以有效提高请求的成功率，但每次都需要mod操作会显著降低效率）

